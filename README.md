
<h1>Dispyrate</h1>

JS-like mapping destructuring. In Python.

---

<h2>Showcase</h2>

```py
>>> from dispyrate import D
>>> data = {'username': 'gmgmgm', 'status': 'active', 'date_joined': '2020-10-22', 'level': 6}
>>> status, level = D(data)
>>> print(status)
active
>>> print(level)
6
```

---

<h2>Rationale</h2>

Sometimes (mostly when doing web backend work), I find myself longing for an equivalent to JS's object destructuring capabilities.

In JS:

```js
> const obj = {a: 1, b: 2}
undefined
> const {a, b} = obj
undefined
> a
1
> b
2
```

Now, Python allows this:

```py
mapping = {'a': 1, 'b': 2}
a, b = mapping  
```

But that, of course, just assigns `'a'` to `a` and `'b'` to `b`, since by default one iterates through a `dict`'s keys.

One might think of doing this:

```py
a, b = mapping.values()
```

That would indeed achieve the same effect as the JS code, *but only because the ordering happens to match*. Consider the following:

```py
>>> mapping = {'c': 3, 'a': 1, 'b': 2}
>>> a, b, c = mapping.values()
>>> print(f'a = {a}, b = {b}, c = {c}')
a = 3, b = 1, c = 2
```

This is clearly not what we want, which is an assignment that matches names to the corresponding string keys in the mapping. There is no support for this in the vanilla language, but thanks to Python's admirable reflection capabilities, we can get quite close with `dispyrate`:

```py
>>> from dispyrate import D
>>> mapping = {'c': 3, 'a': 1, 'e': 5, 'b': 2, 'd': 4}
>>> a, b = D(mapping)
>>> a, b
(1, 2)
>>> a
1
>>> b
2
```

Note that even though the order of names on the left does not match the keys in the mapping, the correct values are still extracted! In addition to the above, remainder arguments are also supported:

```py
>>> c, d, *others = D(mapping)
>>> others
[1, 5, 2]
```

Note that `others` contains the values *other* than `c` and `d`, which is to say, `a`, `b` and `e`, and that they are returned in the order of definition in the source mapping.

---

<h2>Limitations</h2>

`dispyrate` parses the source code as well as the generated bytecode of its caller to determine what order to return arguments in. Because source code is not natively available for the interactive prompt, many non-trivial functions defined interactively will not be able to take advantage of destructuring. For example, something as simple as the following will not work:

```py
>>> mapping = {'b': 2, 'a': 1, 'c': 3}
>>> def f(mapping):
...     constant = 'something'
...     a, b = D(mapping)
... 
>>> f(mapping)
```

---

<h2>Future work</h2>

* See if destructuring can be made to work in all functions defined in the interactive prompt
* Make this an installable package
* Use a class instead of a function for `D` for better structured code
